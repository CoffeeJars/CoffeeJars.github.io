<!doctype html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=680" />
    <link rel="stylesheet" type="text/css" href="../style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@600&display=swap" rel="stylesheet">
    
    <link rel="icon" href="../img/icon.png"/>
    <title>Data Structures I</title>
  </head>
  <body>
    <div class="centered">
      <h1>Array Data Structure in C</h1>
      <p>An array is a fixed number of same-typed elements stored
      contiguously. Each element can be accessed with its index, or
      position within the array, starting from 0. </p>
      <!-- <p>Robert Sedgewick: <i>"."</i></p> -->
      <h2>Basics</h2>
      <p>Let us define an array <code>a</code> of 5 <code>int</code>'s.</p>
<pre>
int a[5]; 
</pre>
      <p>Using the <code>sizeof</code> keyword we can determine how
      many bytes of memory our array is occupying: </p>
<pre>
printf("Array a is taking up %ld bytes of memory.", sizeof(a));
</pre>
<pre>
Array a is taking up 20 bytes of memory.
</pre>
      <p> Makes sense. An integer has a size of 4 bytes on my machine;
      An array of 5 contiguous integers will have a size equal to the
	product 4 * 5 == 20 bytes.</p>
      <p> When using arrays we must be careful to store something
	meaningful at position <code>a[i]</code> before refering to
	it. Let's see why by printing out the contents of the array
	that we just defined above. Iterating over the indices using
	a <code>for</code> loop we can print the value of each
	element:</p>
<pre>
for (int i=0; i<5; i++)
    printf("a[%d]: %d\n", i, a[i]);
</pre>
<pre>
a[0]: 486936992
a[1]: 21997
a[2]: 486936656
a[3]: 21997
a[4]: -1626839984
</pre>
      <p> Allocating an array does not clear the bits within that
      memory, the values we read from this uninitialized array are
      simply the values that existed before our allocation. If we did
      wish to initalize an array filled with 0s we could have instead
      defined the array like this:</p>
<pre>
int a[5] = {0};
</pre>
      <p>Re-running our <code>for</code> loop from above:</p>
<pre>
a[0]: 0
a[1]: 0
a[2]: 0
a[3]: 0
a[4]: 0
</pre>
      <p>Another sharp edge of C is the lack of guardrails on array
	access. We are free to shoot ourselves in the foot and access
	an "element" of the array that may not really be part of the
	array at all. </p>
      <p> Let us adjust the <code>for</code> loop code to demonstrate this.</p>
<pre>
for (int i=-2; i<7; i++)
    printf("a[%d]: %d\n", i, a[i]);
</pre>
      <p>The dummy variable i now starts at -2 and reads until array
	index 6.</p>
<pre>
a[-2]: 0
a[-1]: 21940
a[0]: 0
a[1]: 0
a[2]: 0
a[3]: 0
a[4]: 0
a[5]: 32766
a[6]: 0
</pre>
      <p>Here we can see that our <code>a</code> array has been
      correctly initialized to all zeros. However <code>A[-1], A[-2],
      A[5], A[6]</code> are not really part of this array at all, and
      thus, have not been properly initialized.</p>
      <p>Reading erroneous memory is bad, but writing data to the
      wrong address in memory might be even worse. Imagine if we had
      declared some additional variables inside
      our <code>main(void)</code> function:</p>
<pre>
#define N 5

int main(void) {
  int a[N] = {0};
  int b = 42;

  for (int i=-2; i<7; i++) {
    a[i] = 1;
  }
  printf("b=%d\n",b);
  return 0;
}
</pre>
<pre>
b=1
</pre>
      <p><code>b</code> was assigned to 42, but by being adjacent
	to <code>a</code> in memory, this value was accidentally
	overwritten with an improper value.</p>
      <p>Writing past either end of the array may overwrite the dummy
	iteration variable you were using to iterate in the first
	place! In our example, this is <code>i</code> which we are
	purposefully letting roam a bit too free between -2 and
	6. If <code>i</code> is overwritten by writing past the ends
	of the array into the array, our intended array access with be
	destroyed. </p>
      <h2>The Sieve of Eratosthenes</h2>
      <p>A classic algorithm to find prime numbers below a given int N.</p>
<pre>
#define N 1000
int i, j, a[N+1];
for (a[1] = 0, i = 2; i < N; i++) {
  a[i] = 1;
}
for (i=2; i<= N/2; i++) {
  for (j=2; j<=N/i; j++) {
    a[i*j] = 0;
  }
}
for(i = 1; i <= N; i++)
  if(a[i]) printf("%4d", i);
printf("\n");
</pre>

      <h2>The Game of Life</h2>
      <p></p>

    </div>
  </body>
</html>
