<!doctype html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=500" />
    <link rel="stylesheet" type="text/css" href="style.css">
    <link rel="icon" href="../img/icon.png"/>
    <title>C Reference</title>
  </head>
  
  <body>
    <!-- Sidebar -->

    <div class="centered">
      <a name="lexical"></a>
      <h2>Lexical Elements</h2>
      <p>A C source file is a sequence of characters. Legal characters
      are the 52 Latin capital and small letters,</p>
      <table>
	<tr>
	  <td class="mono">A<iv></td> <td class="mono">B</td> <td class="mono">C</td> <td class="mono">D</td> <td class="mono">E</td> <td class="mono">F</td> <td class="mono">G</td> <td class="mono">H</td> <td class="mono">I</td> <td class="mono">J</td> <td class="mono">K</td> <td class="mono">L</td> <td class="mono">M</td> <td class="mono">N</td> <td class="mono">O</td> <td class="mono">P</td> <td class="mono">Q</td> <td class="mono">R</td> <td class="mono">S</td> <td class="mono">T</td> <td class="mono">U</td> <td class="mono">V</td> <td class="mono">W</td> <td class="mono">X</td> <td class="mono">Y</td> <td class="mono">Z</td>
	</tr>
	<tr>
	  <td class="mono">a</td><td class="mono">b</td><td class="mono">c</td><td class="mono">d</td><td class="mono">e</td><td class="mono">f</td><td class="mono">g</td><td class="mono">h</td><td class="mono">i</td><td class="mono">j</td><td class="mono">k</td><td class="mono">l</td><td class="mono">m</td><td class="mono">n</td><td class="mono">o</td><td class="mono">p</td><td class="mono">q</td><td class="mono">r</td><td class="mono">s</td><td class="mono">t</td><td class="mono">u</td><td class="mono">v</td><td class="mono">w</td><td class="mono">x</td><td class="mono">y</td><td class="mono">z</td>
	</tr>
      </table>
      <p> the 10 digits, </p>
      <table>
	<tr>
	  <td class="mono">0</td>
	  <td class="mono">1</td>
	  <td class="mono">2</td>
	  <td class="mono">3</td>
	  <td class="mono">4</td>
	  <td class="mono">5</td>
	  <td class="mono">6</td>
	  <td class="mono">7</td>
	  <td class="mono">8</td>
	  <td class="mono">9</td>
	</tr>
      </table>
      <p>the SPACE , <br>
	the horizontal tab (HT), vertical tab (VT), form
	feed (FF) control characters, <br> and 29 graphic
	characters: <p>
	<table style="width: 100%;">
	  <tr><td class="mono">!</td><td>EXCLAMATION MARK</td> <td class="mono">+</td><td>PLUS SIGN</td> <td class="mono">"</td><td>QUOTATION MARK</td> </tr>
	  <tr><td class="mono">#</td><td>NUMBER SIGN</td> <td class="mono">=</td><td>EQUALS SIGN</td> <td class="mono">{</td><td>LEFT CURLY BRACKET</td> </tr>
	  <tr><td class="mono">%</td><td>PERCENT SIGN</td> <td class="mono">~</td><td>TILDE</td> <td class="mono">}</td><td>RIGHT CURLY BRACKET</td> </tr>
	  <tr><td class="mono">^</td><td>CIRCUMFLEX ACCENT</td> <td class="mono">[</td><td>LEFT SQUARE BRACKET</td> <td class="mono">,</td><td>COMMA</td> </tr>
	  <tr><td class="mono">&</td><td>AMPERSAND</td> <td class="mono">]</td><td>RIGHT SQUARE BRACKET</td> <td class="mono">.</td><td> FULL STOP </td> </tr>
	  <tr><td class="mono">*</td><td>ASTERISK</td> <td class="mono">'</td><td>APOSTROPHE</td> <td class="mono"><</td><td>LESS-THAN SIGN</td> </tr>
	  <tr><td class="mono">(</td><td>LEFT PARENTHESIS</td> <td class="mono">|</td><td>VERTICAL LINE</td> <td class="mono">></td><td>GREATER-THAN SIGN</td> </tr>
	  <tr><td class="mono">_</td><td>LOWLINE</td> <td class="mono">\</td><td>REVERSE SOLIDUS</td> <td class="mono">/</td><td>SOLIDUS</td> </tr>
	  <tr><td class="mono">)</td><td>RIGHT PARENTHESIS</td> <td class="mono">;</td><td>SEMICOLON</td> <td class="mono">?</td><td>QUESTION MARK</td> </tr>
	  <tr><td class="mono">-</td><td>HYPHEN-MINUS</td> <td class="mono">:</td><td>COLON</td></tr>
	</table>

      <p>Solidus and reverse solidus are the familiar slash and backslash. Lowline is an underscore. </p>

      <a name="keywords"></a>
      <h2>Keywords</h2>
      <p>Some combinations of characters are called keywords. These
      words have spcial meaning to the compiler and cannot be used for
      variables or identifiers.</p>
      
      <table>
	<tr><td>auto</td><td>break</td><td>case</td></tr>
	<tr><td>char</td><td>const</td><td>continue</td></tr>
	<tr><td>default</td><td>do</td><td>double</td></tr>
	<tr><td>else</td><td>enum</td><td>extern</td></tr>
	<tr><td>float</td><td>for</td><td>goto</td></tr>
	<tr><td>if</td><td>int</td><td>long</td></tr>
	<tr><td>register</td><td>return</td><td>short</td></tr>
	<tr><td>signed</td><td>sizeof</td><td>static</td></tr>
      </table>
      
      <p>Static variables have a permenant memory
	    address. A static variable local to a function will be
	    initalized upon the first call and will persist between
	calls.</p>


<p>sizeof keyword is an operator which determines the size of
      the argument in bytes at compile time.</p>
<p> continue keyword is sort of like break. It forces the next step of
	    iteration skipping all the remaining code within the
	    looping construct.
</p>


      <a name="compile"></a>
      <h2>Compilation</h2>
      <p>C is a compiled language. Computer languages like C use a program called a compiler to
	convert between human readable source code and machinecode which can be executed on a CPU. </p>
      <p>We will now step through the stages of c compilation.</p>
      <!-- <p>Expand conceptually on compilation vs dynamic languages with -->
      <!-- 	interpreters.</p> -->
      


	
      <a name="prepro"></a>
      <h2>The Preprocessor</h2>
      <p>Lines which begin with a # communicate with the
      preprocessor. These lines are known as directives.</p>

      <p>The first step of compilation is preprocessing. According to
              the <code>man cc</code>, <i>"This stage handles
              tokenization of the input source file, macro expansion,
              #include expansion and handling of other preprocessor
              directives.  The output of this stage is typically
          called a ".i" (for C)..."</i></p>

      <p>To see this .i file:</p>
<code><pre>
$ cc -E input.c
</pre></code>
      <p> C being a spartan language, requires including standard
      library code often. This is done with the #include
      directive.</p>
<code><pre>
#include &lt;stdio.h&gt;
</pre></code>
      <p>The include directive instructs the preprocessor to paste the
      contents of the stdio.h header file into the current file at the
      location of the directive. The angle brackets indicate that this
      header file is located in a system dependent "usual" place. </p>
<code><pre>
#include "aheader.h"
</pre></code>
      <p>The include directive can be used with quotes instead of
      brackets to specify a path to the header file. This is useful
      for headers in the local directory to the project, usually ones
      you write yourself.</p>
<pre>
#define TRUE 1
#define FALSE 0
</pre>
      <p>The #define directive will do a text substitution at compile
	time to replace all instances of TRUE, FALSE with 1, 0. This
	is an idiom seen a lot in old C textbooks to define
	constants. Memory is cheap now, use const instead.</pachycladous>

      <p>https://randu.org/tutorials/c/basic2.php</p>

      <!-- <h2>Lexical Analysis</h2> -->
      <!-- <h2>Syntax Analysis</h2> -->
      <!-- <h2>Semantic Analysis</h2> -->
      <!-- <h2>Makefiles</h2> -->
      

      <a name="comments"></a>
      <h2>Comments</h2>
      <p>You spend more time reading your code than the computer
	does. Leave concise and helpful comments. Old comments can be
      misleading, so prune back irrelevant or unnecessary ones. </p>
<code><pre>
/* Between the "slash star" and the "star slash" is a comment in c. */
// From C99 onward you can do a line comment with a double slash.
</code></pre>
      <p>Rob Pike in <a href="http://doc.cat-v.org/bell_labs/pikestyle" target="_blank">Notes on Programming in C</a>: <i>"...keep comments brief and
	banner-free. Say what you want to say in the program, neatly and
	  consistently. Then move on."</i></p>
	      
      <p><a href="https://www2.cs.arizona.edu/~mccann/styletemplatesCP.html"
	    target="_blank">Prof. McCann</a> argues: <i>" It has been
	  estimated that about 70% of programming effort is put into
	  the maintenance of old code ... Commenting exists to help
	  those unfortunate programmers who have to look at the code
	  months or years after it was written."</i></p>
      <p>Strike a healthy balance between over and under
	commenting. Comments are not checked by the compiler, meaning they can
	lie to you. However, well written and purpose-describing
	comments can make debugging, maintaining, and replacing code easier.</p>


<a name="progstyle"></a>
<h2>C Programming Style</h2>
      <p>Rob Pike: <i>"A program is a sort of publication. It's meant
	  to be read by the programmer, another programmer (perhaps
	  yourself a few days, weeks or years later), and lastly a
	  machine."</i></p>
	
	<a name="array"></a>
      <h2>Array Data Structure in C</h2>
      <p>An array is a fixed number of same-typed elements stored
	contiguously. Each element can be accessed with its index, or
	offset into the array, starting from 0. So</p>
<pre>
/* type name[len]; */
int array[5]; /* defines a[0 ... n-1] */
array[2] = 3;
</pre>
      <p>There is an elegant connection between pointers and array
	indices. <code>name[n]</code> notation is syntax sugar for the
	pointer expression <code>*((name) + (n))</code>. Where the
	pointer to name is incrememted n places and then
	dereferenced. </p>


      
      <!-- <p>Robert Sedgewick: <i>"."</i></p> -->
      <h2>Vectors</h2>
      <p>A one-dimensional array can be considered a vector from
      mathematics. Numerical recipes in C authors suggest the use of
      a <i>unit offset vector</i> in order to index c vectors
      implemented as arrays from 1 instead of 0. There is a simple way
      to use the power of c to index an array [1 ... n] instead of [0
      ... n-1]. of course there are times when you still want to
      index from 0, an example being dsp applications.</p>
<pre>
float b[4], *bb;
bb=b-1;
</pre>
      <p>This snippet declares b to be an array of 4 floats: b[0],
      b[1], b[2], b[3]. bb is declared as a pointer to the
      (non-existant) float before the b array. Deferencing bb would be
      reading an illegal memory value, but bb can be accessed with
      indicies 1 through 4: bb[1], bb[2], bb[3], bb[4]. This makes
      using an offset like this appealing for implementing matrix and
      vector operations.</p>
      <p>You can really tell that these people were fortran
      programmers.. Still, the idea deserves consideration and could
      create some very clean numerical code. </p>

      <h2>Basics</h2>
      <p>Let us define an array <code>a</code> of 5 <code>int</code>'s.</p>
<pre>
int a[5]; 
</pre>
      <p>Using the <code>sizeof</code> keyword we can determine how
      many bytes of memory our array is occupying: </p>
<pre>
printf("Array a is taking up %ld bytes of memory.", sizeof(a));
</pre>

<pre>
Array a is taking up 20 bytes of memory.
</pre>
      <p> Makes sense. An integer has a size of 4 bytes on my machine;
      An array of 5 contiguous integers will have a size equal to the
	product 4 * 5 == 20 bytes.</p>
      <p> When using arrays we must be careful to store something
	meaningful at position <code>a[i]</code> before refering to
	it. Let's see why by printing out the contents of the array
	that we just defined above. Iterating over the indices using
	a <code>for</code> loop we can print the value of each
	element:</p>
<pre>
for (int i=0; i<5; i++)
    printf("a[%d]: %d\n", i, a[i]);
</pre>
<pre>
a[0]: 486936992
a[1]: 21997
a[2]: 486936656
a[3]: 21997
a[4]: -1626839984
</pre>
      <p> Allocating an array does not clear the bits within that
      memory, the values we read from this uninitialized array are
      simply the values that existed before our allocation. If we did
      wish to initalize an array filled with 0s we could have instead
      defined the array like this:</p>
<pre>
int a[5] = {0};
</pre>
      <p>Re-running our <code>for</code> loop from above:</p>
<pre>
a[0]: 0
a[1]: 0
a[2]: 0
a[3]: 0
a[4]: 0
</pre>
      <p>Another sharp edge of C is the lack of guardrails on array
	access. We are free to shoot ourselves in the foot and access
	an "element" of the array that may not really be part of the
	array at all. </p>
      <p> Let us adjust the <code>for</code> loop code to demonstrate this.</p>
<pre>
for (int i=-2; i<7; i++)
    printf("a[%d]: %d\n", i, a[i]);
</pre>
      <p>The dummy variable i now starts at -2 and reads until array
	index 6.</p>
<pre>
a[-2]: 0
a[-1]: 21940
a[0]: 0
a[1]: 0
a[2]: 0
a[3]: 0
a[4]: 0
a[5]: 32766
a[6]: 0
</pre>
      <p>Here we can see that our <code>a</code> array has been
      correctly initialized to all zeros. However <code>A[-1], A[-2],
      A[5], A[6]</code> are not really part of this array at all, and
      thus, have not been properly initialized.</p>
      <p>Reading erroneous memory is bad, but writing data to the
      wrong address in memory might be even worse. Imagine if we had
      declared some additional variables inside
      our <code>main(void)</code> function:</p>
<pre>
#define N 5

int main(void) {
  int a[N] = {0};
  int b = 42;

  for (int i=-2; i<7; i++) {
    a[i] = 1;
  }
  printf("b=%d\n",b);
  return 0;
}
</pre>
<pre>
b=1
</pre>
      <p><code>b</code> was assigned to 42, but by being adjacent
	to <code>a</code> in memory, this value was accidentally
	overwritten with an improper value.</p>
      <p>Writing past either end of the array may overwrite the dummy
	iteration variable you were using to iterate in the first
	place! In our example, this is <code>i</code> which we are
	purposefully letting roam a bit too free between -2 and
	6. If <code>i</code> is overwritten by writing past the ends
	of the array into the array, our intended array access with be
	destroyed. </p>
      <h2>The Sieve of Eratosthenes</h2>
      <p>A classic algorithm to find prime numbers below a given int N.</p>
<pre>
#define N 1000
int i, j, a[N+1];
for (a[1] = 0, i = 2; i < N; i++) {
  a[i] = 1;
}
for (i=2; i<= N/2; i++) {
  for (j=2; j<=N/i; j++) {
    a[i*j] = 0;
  }
}
for(i = 1; i <= N; i++)
  if(a[i]) printf("%4d", i);
printf("\n");
</pre>

      <h2>The Game of Life</h2>
<pre>      
/* Game of Life Simulation: 
   Author: Stephen Duncanson, spring 2022 
   Reference: Data structures and Program Design in C by Robert Kruse 
   Rules: Cells are either alive or dead on a rows * cols sized grid the
   state of these cells change on generational boundaries, the steps
   in the simulation. Whether a cell will die, remain alive, or become
   alive depends on how many of the 8 adjacent neighbors are alive. If
   a cell is dead it will become alive if it has exactly 3
   neighbors. If a cell is alive it will die if it has 4 or more
   neighbors. It will remain alive if it has 2 or 3 neighbors. */

#include stdio.h
#include stdlib.h
#include unistd.h

const int rows = 20;
const int cols = 40;
const int gens = 50;

void clearscr(void);

unsigned int count8(int board[rows][cols], int i, int j) {
  unsigned int neighbors = 0;
  /* Assumes board is a 2d array where each element is alive 1 or dead 0. 
     ......... where C is the cell denoted by board[i][j]
     ..xxx.... and each x is one of the neighbors. Depending on our location on
     ..xCx.... the board we may not have a neighbor on each side. 
     ..xxx.... For example on the first or last row of the grid.
     ......... First check if we can have the neighbor, and add its value to count. */
  neighbors += ((i > 1 && j > 1) ? board[i-1][j-1] : 0);	/* NW */
  neighbors += ((i > 1) ? board[i-1][j] : 0);	                /* N */
  neighbors += ((i > 1 && j < cols-2) ? board[i-1][j+1] : 0);	/* NE */
  neighbors += ((j < cols-2) ? board[i][j+1] : 0);        	/* E */
  neighbors += ((i < rows-2 && j < cols-2) ? board[i+1][j+1] : 0);/* SE */
  neighbors += ((i < rows-2) ? board[i+1][j] : 0);      	/* S */
  neighbors += ((i < rows-2 && j > 1) ? board[i+1][j-1] : 0);	/* SW */
  neighbors += ((j > 0) ?  board[i][j-1] : 0);	/* W */
  return neighbors;
}

void updateBoard(int board_curr[rows][cols], int board_next[rows][cols]) {
  /* replace board_curr[] with board_next[] and refresh stdout for the
     new board_current */
  unsigned int adjacent_count = 0;
  for (int i=0; i < rows; i++) {
    for (int j=0; j < cols; j++) {
      adjacent_count = count8(board_curr, i, j);
      if (adjacent_count == 3) {  board_next[i][j] = 1; }
      else if (adjacent_count == 2 && board_curr[i][j])  { board_next[i][j] = 1; }
      else { board_next[i][j] = 0; }
    }
  }

  for (int i=0; i < rows; i++) {
    for (int j=0; j < cols; j++) {
      board_curr[i][j] = board_next[i][j];
    }
  }

  clearscr();
}

void initBoard(int board[rows][cols]) {
  
  for (int i=0;i < rows;i++) {
    for (int j=0; j < cols;j++){
      
      /* random init logic for now, all even cells */
      if (i==j || i%2==1 ) { board[i][j]=1; }
      else { board[i][j]=0; }
    }
  }
  return;
}

void clearscr(void) {
#ifdef _WIN32
    system("cls");
#elif defined(unix) || defined(__unix__) || defined(__unix) || (defined(__APPLE__) && defined(__MACH__))
    system("clear");
    /* add some other OSes here if needed */
#else
#error "OS not supported."
#endif
}

void printBoard(const int board[rows][cols]) {
  /* use const as promise not to change board board[] is of unknown
     size at compile time.
   */
  for (int i=0; i < rows; i++) {
    for (int j=0; j < cols; j++) {
      printf("%c",board[i][j] ? '#' : '.');
    }
    printf("\n"); 
  }
}
      
int main(void) {
  int current_board[rows][cols] = {0};
  int future_board[rows][cols] = {0};
  
  initBoard(current_board);

  for (int g=0; g < gens-1; g++) {
    printf("Generation %d:\n",g);
    printBoard(current_board);
    updateBoard(current_board, future_board);
  }
  printBoard(current_board);
  
  return 0;
}
</pre>

<a name="typedef"></a>
<h2>Typedefs</h2>
<p>The C language standard has different namespaces for different
  catagories of identifiers. <i>tag identifiers</i> for
  struct/enum/union names and <i>ordinary identifiers</i> for typedef
  and others.</p>
<p>If you type:</p>
<pre>
struct Foo { ... };
Foo x;
</pre>
<p>You will get a compiler error because Foo is only defined in the tag namespace. </p>
<p>Instead you have to do: </p>
<pre>
struct Foo x;  
</pre>
<p> Any time you want to refer to a Foo, you would need to call it a struct Foo. This gets annoying. So you can use a typedef:</p>
<pre>
struct Foo { ... };
typedef struct Foo Foo;  
</pre>
<p>Now struct Foo is in tag namespace and Foo is in ordinary
  namespace. Both refer to the same thing.</p>
<p>The idiom:</p>
<pre>
typedef struct Foo { ... } Foo;
</pre>
<p>Is a nice shorthand for a declaration and typedef.</p>
<a name="sockets"></a>
<h2>Network Sockets</h2>
<p> See: Beejs Guide to Network Programming<br> What is a socket?
  UNIX does all I/O by reading or writing to a file descriptor.  A
  file descriptor is an integer associated with an open file. The OS
  maintains a table of file descriptors for every open process.  How
  do we get a socket? call socket() How do we communicate through the
  socket? send() and recv().  We could use normal read() and write()
  but send() and recv() give us more control.</p>
   
<p> Two types of sockets: Stream sockets "SOCK_STREAM" Datagram
   sockets "SOCK_DGRAM"</p>

<a name="pthread"></a>
<h2>pthreads</h2>
<p>This would be a nice place to quote k and r about how c does not
support concurrency.</p>
<p>C supports concurrency at an OS level, the pthread (POSIX) thread library includes functions for multithreading.</p>


<a name="avr"></a>
<h2>XplainedMini (Atmega328PB)</h2>
<p> Atmels XplainedMini boards, using the mEDBG protocol, are also
  supported using the "jtag3" programmer type.</p>
<p>
  avrdude -c xplainedmini -p m328pb </p>

    </div>
  </body>
</html>

